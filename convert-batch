#!/bin/bash
dirStructure=same
while getopts "hs:m:q:x:r:znlt" flag
do
  case $flag in
    h ) help=y;;
    s ) size=$OPTARG;;
    m ) match=$OPTARG;;
    q ) quality=$OPTARG;;
    x ) exclude=$OPTARG;;
    r ) replace=$OPTARG;;
    z ) zoom=y;;
    n ) dryrun=y;;
    l ) dirStructure=relative;;
    t ) dirStructure=flat;;
  esac
done
shift $((OPTIND-1)); OPTIND=1

sourcedir=$1
destdir=$2

if [[ y = $help || -z $sourcedir ]]; then
  echo "USAGE: batch_jpeg [ -s <geometry> ] [ -z ] [ -q <quality (70)> ]
       [ -m <match pattern (*.jpg)> ] [ -e <exclude pattern> ] [ -l ] [ -n ]
       <source dir> [ <destination dir> ]

OPTIONS:

  -s  Output image size, as <width>x<height>.

  -h  Show this information.

  -m  Pattern to match files for processing, default *.jpg.

  -l  Output directory is created relative to each file. If -e is not given, it
      is set to exclude this directory.

  -t  Output files are put in the same directory, ignoring the source
      directory's structure

  -q  Quality, 0-100, default 70.

  -e  Exclude file pattern. If -l is used, this defaults to exclude that
      path.

  -r  PERL regular expression to transform the output filenames.

  -z  Zoom image to fill new ratio. Without this option the image aspect is
      preserved.

  -n  Print the source and output filenames without writing any files or
      creating any directories."
  exit 0
fi
wd=$(pwd)
if [[ -z $destdir && "$dirStructure" != relative ]]; then destdir="$sourcedir"; fi
if [[ -z $match ]]; then match=\*.jpg; fi
if [[ -z $quality ]]; then quality=70; fi
if [[ -n $destdir && $dirStructure != relative && ${destdir:0:1} != "/" ]]; then
  # -r not set, make destdir an absolute path
  destdir="$wd/$destdir"
fi
if [[ "$dirStructure" = relative && -z "$exclude" ]]; then
  exclude=\*$destdir\*
fi
cd "$sourcedir"
if [[ -n $exclude ]]; then
  excludefiles=$(find . -path "$exclude")
fi
SAVEIFS=$IFS
IFS=$(echo -en "\n\b")
if [[ y = $dryrun ]]; then
  echo "DRY RUN"
fi
for file in $(find . -path "$match"); do
  if [[ -n $exclude && -n $(echo $excludefiles | grep $file) ]]; then
    continue # skip excluded files
  fi
  src="$file"
  if [[ -n $replace ]]; then
    output_basename=$(basename $file | perl -pe "s$replace")
  else
    output_basename=$(basename $file)
  fi
  if [[ relative = $dirStructure ]]; then
    output="$(dirname $file)/$destdir/$output_basename"
  elif [[ flat = $dirStructure ]]; then
    output="$destdir/$output_basename"
  else
    output="$destdir/$src"
  fi
  echo -e "\nSOURCE: $file\nOUTPUT: $output"
  if [[ -z $dryrun ]]; then
    mkdir -p "$(dirname "$output")"
    resizeOption=
    zoomOption=
    if [[ -n $size ]]; then
      resizeOption="-resize ${size}"
      if [[ y = $zoom ]]; then
        resizeOption="$resizeOption^"
        zoomOption="-gravity Center -crop $size+0+0"
      fi
    fi
    qualityOption="-quality $quality"
    command="convert $resizeOption $zoomOption \"$src\" $qualityOption \"$output\""
    eval ${command}
    test $? -gt 1 && break # break entire loop on interrupt (ctrl+c) on Mac
  fi
done
IFS=$SAVEIFS
